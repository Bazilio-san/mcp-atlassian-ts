#!/bin/bash

# Default branch
branch="master"
useNodeVersion="22.17.1"

################################################################################
# Get the absolute path of the script and change to project directory
ABS_SCRIPT_PATH="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/$(basename "${BASH_SOURCE[0]}")"
WD="$(dirname "$ABS_SCRIPT_PATH")"

# Change to the project directory FIRST
cd "$WD"

c='\033[0;35m'
y='\033[0;33m'
w='\033[0;0m'
g='\033[0;32m'
lg="\033[0;32m";

echo_g() { /bin/echo -e "$g$1$w"; }
echo_lg()    { if [ "$2" = "" ]; then /bin/echo -e "$lg$1$w"; else /bin/echo -en "$lg$1$w"; fi  }
echo_y() { /bin/echo -e "$y$1$w"; };

echo_g "========================================"
echo_g "Working directory: ${y}${WD}${g}"
echo_g "========================================"

# Check for .envrc and use it, otherwise use nvm with useNodeVersion
if [ -f ".envrc" ]; then
  echo_g "Loading .envrc..."
  source .envrc
else
  echo_g "Using Node.js version: ${useNodeVersion}"
  export NVM_DIR="$HOME/.nvm"
  [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvm
  nvm use ${useNodeVersion}
fi

parse_yaml() {
  local prefix=$2
  local s='[[:space:]]*' w='[a-zA-Z0-9_]*' fs=$(echo @|tr @ '\034')
  sed -ne "s|^\($s\)\($w\)$s:$s\"\(.*\)\"$s\$|\1$fs\2$fs\3|p" \
    -e "s|^\($s\)\($w\)$s:$s\(.*\)$s\$|\1$fs\2$fs\3|p"  $1 |
  awk -F$fs '{
    indent = length($1)/2;
    vname[indent] = $2;
    for (i in vname) {if (i > indent) {delete vname[i]}}
    if (length($3) > 0) {
       vn=""; for (i=0; i<indent; i++) {vn=(vn)(vname[i])("_")}
       printf("%s%s%s=\"%s\"\n", "'$prefix'",vn, $2, $3);
    }
  }'
}

# Function to send build notification to multiple email addresses
send_build_notification() {
  local emails=$1
  local status=$2
  local build_log=$3

  if [[ -z "$emails" ]]; then
    return
  fi

  local emailLogFile="${WD}/update__${SERVICE}__email.log"

  # Create HTML wrapper
  cat << EOF > "$emailLogFile"
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
    <meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>${status} Update ${SERVICE} (on ${HOSTNAME})</title>
</head>
<body>
<pre>
EOF

  # Add build log content (remove ANSI color codes)
  printf "%b\n" "$build_log" | sed -r 's/\x1B\[(;?[0-9]{1,3})+[mGK]//g' >> "$emailLogFile"

  # Close HTML
  cat << EOF >> "$emailLogFile"

</pre></body></html>
EOF

  # Split comma-separated email addresses and send to each one
  IFS=',' read -ra EMAIL_ADDRESSES <<< "$emails"
  for email_address in "${EMAIL_ADDRESSES[@]}"; do
    # Trim whitespace from email address
    email_address=$(echo "$email_address" | xargs)
    if [ -n "$email_address" ]; then
      echo_g "Sending update notification to: $email_address"
      # Send email with HTML content type using redirect
      mail -s "$(echo -e "${status} Update: $SERVICE (on ${HOSTNAME})\nContent-Type: text/html")" "$email_address" < "$emailLogFile"
    fi
  done

  # Clean up temporary email file
  sleep 1
  rm -f "$emailLogFile"
}

IFS='' read -r -d '' help <<'EOF'
================================================================================
    Project update and rebuild

    Usage:
        ./update [Options]

    Options:

    -b|--branch
        GIT branch name. Default - master
    -l|--log
        Switch to log display mode after completion
    -?|--help
        Display help

    Example: ./update -b production -l
================================================================================
EOF


# -e  Exit immediately if a command exits with a non-zero status.
set -e

args="$@";
while [[ $# -gt 0 ]]; do
  key="$1"
  case $key in
    -b|--branch)
    expectedBranch=$2
    shift; shift;;
    -l|--log)
    showLog="1"
    shift;;
    *) shift;;
  esac
done
set -- $args

for i in "$@" ; do
  if [[ $i =~ (-\?|--help) ]]; then
    echo_lg "$help"
    exit;
  fi
done


################################################################################
# Create deploy folder if it doesn't exist
[ -d deploy ] || mkdir deploy

# Parse config if exists
configFile="./deploy/config.yml"
if [ -f "$configFile" ]; then
  eval $(parse_yaml $configFile)
fi

# Trim whitespace from variables
branch=`echo $branch`;
nodeVersion=`echo $nodeVersion`;
email=`echo $email`;

# Set default branch if not specified
if [ -z "$branch" ]; then
  branch="master"
fi

# Compare current config with file and re-save if different
compare1=$(echo `cat $configFile 2>/dev/null` | tr -d ' ')
compare2="branch:${branch}nodeVersion:${nodeVersion}email:${email}"

if ! [[ "$compare1" = "$compare2" ]]; then
  echo_lg "Creating/updating the config file: $configFile"
  # Save config
  echo "branch: $branch" > $configFile
  echo "nodeVersion: $nodeVersion" >> $configFile
  echo "email: $email" >> $configFile
fi

################################################################################

if [[ -n $expectedBranch ]]; then
  expected_branch=$expectedBranch
else
  expected_branch=$branch
fi

SERVICE_NAME=`cat package.json | grep name | head -1 | awk -F: '{ print $2 }' | sed 's/[\",]//g' | tr -d '[[:space:]]'`
SERVICE_NAME_ALT=`cat .env | grep SERVICE_NAME | head -1 | awk -F= '{ print $2 }'`
SERVICE_NAME="${SERVICE_NAME_ALT:-$SERVICE_NAME}"
# Trim possible spaces and CR/LF
SERVICE_NAME=$(echo "$SERVICE_NAME" | tr -d '\r' | xargs)

SERVICE_INSTANCE=`cat .env | grep SERVICE_INSTANCE | head -1 | awk -F= '{ print $2 }'`
# Trim possible spaces and CR/LF
SERVICE_INSTANCE=$(echo "$SERVICE_INSTANCE" | tr -d '\r' | xargs)

if [ -z "$SERVICE_INSTANCE" ]
then
  SERVICE="${SERVICE_NAME}"
else
  SERVICE="${SERVICE_NAME}--${SERVICE_INSTANCE}"
fi

# Just in case, trim final service name (remove CR/LF and external spaces)
SERVICE=$(echo "$SERVICE" | tr -d '\r' | xargs)

service_exists() {
  local n=$1
  systemctl list-unit-files "${n}.service" 2>/dev/null | grep -q "${n}.service"
}

pm2_service_exists() {
  local n=$1
  pm2 id "$n" >/dev/null 2>&1
}

echo_g "========================================"
echo_g "**** RENEW ${y}${SERVICE}${g} ****"
echo_g "========================================"

# Initialize build log
BUILD_LOG="Update started at $(date '+%Y-%m-%d %H:%M:%S')\n"
BUILD_LOG+="Service: ${SERVICE}\n"
BUILD_LOG+="Working directory: ${WD}\n"
BUILD_LOG+="========================================\n\n"

repo_info() {
  local currentHash=$(git rev-parse --short HEAD)
  local currentCommitMessage=$(git log -n 1 --pretty=format:%s ${currentHash})
  local currentCommitDate=$(git log -n 1 --format="%at" ${currentHash} | xargs -I\{} date -d @\{} +%d.%m.%Y_%H:%M:%S)
  local currBranch=$(git rev-parse --abbrev-ref HEAD)
  echo_g "Current branch: ${ly}${currBranch}"
  echo_g "Last commit: ${ly}${currentHash}${g}, date: ${lm}${currentCommitDate}"
  echo_g "message: ${lm}${currentCommitMessage}"
  echo_g "----------------------------------------"

  # Add to build log
  BUILD_LOG+="Current branch: ${currBranch}\n"
  BUILD_LOG+="Last commit: ${currentHash}, date: ${currentCommitDate}\n"
  BUILD_LOG+="Message: ${currentCommitMessage}\n"
  BUILD_LOG+="----------------------------------------\n"
}

currentBranch=$(git rev-parse --abbrev-ref HEAD)

echo_g "Expected_branch: ${expected_branch}"
echo_g "Current_branch: ${currentBranch}"

if [ "$currentBranch" != "$expected_branch" ]; then
  git reset --hard @{u}
  isBranchSwitched="YES"
  echo_g "Switch tracking from branch \"$currentBranch\" to \"$expected_branch\""
  git checkout -f $expected_branch
fi

echo_g "=============== git pull ==============="
BUILD_LOG+="Git pull from branch: ${expected_branch}\n"

git pull origin $expected_branch 2>/dev/null

repo_info

echo_g "====== CLEAN INSTALL DEPENDENCIES ======"
BUILD_LOG+="Clean install dependencies\n"

rm -rf node_modules/
yarn install --frozen-lockfile
BUILD_LOG+="Dependencies installed\n"

echo_g "========== TYPESCRIPT BUILD =========="
BUILD_LOG+="TypeScript build started\n"
rm -rf ./dist
npm run build
echo_y "typescript build done"
BUILD_LOG+="TypeScript build completed\n"


if service_exists "$SERVICE"
then
  echo_g "========== Restarting service ${SERVICE} via systemctl =========="
  BUILD_LOG+="========== Restarting service: ${SERVICE} via systemctl ==========\n"
  systemctl restart "$SERVICE"
  echo_g "**** Service $g$SERVICE$c restarted via systemctl ****"
  BUILD_LOG+="Service restarted via systemctl\n"
  if [[ -n "$showLog" ]]; then
    journalctl -o cat -xefu "$SERVICE"
  fi
elif pm2_service_exists "$SERVICE"
then
  echo_g "========== Restarting service ${SERVICE} via PM2 =========="
  BUILD_LOG+="========== Restarting service: ${SERVICE} via PM2 ==========\n"
  pm2 restart "$SERVICE"
  echo_g "**** Service $g$SERVICE$c restarted via PM2 ****"
  BUILD_LOG+="Service restarted via PM2\n"
  if [[ -n "$showLog" ]]; then
    pm2 logs "$SERVICE" --lines=1000
  fi
else
  echo_g "Service $SERVICE not found in systemctl or PM2"
  BUILD_LOG+="Service $SERVICE not found in systemctl or PM2\n"
fi

# Add completion info to build log
BUILD_LOG+="========================================\n"
BUILD_LOG+="Update completed successfully at $(date '+%Y-%m-%d %H:%M:%S')\n"
echo_g "#SUCCESS#"

# Send build notification if email is configured
if [ -n "$email" ]; then
  echo_g "================= SENDING EMAIL ================"
  send_build_notification "$email" "SUCCESS" "${BUILD_LOG}"
else
  echo_g "EMAIL not found"
fi

exit 0
